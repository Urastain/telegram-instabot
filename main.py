import os
import asyncio
import logging
import tempfile
import threading
import time
from flask import Flask, request, jsonify
from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    ContextTypes,
    filters
)
import httpx
import yt_dlp
from urllib.parse import urlparse

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–æ–≤
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏–∑ –æ–∫—Ä—É–∂–µ–Ω–∏—è
TOKEN = os.getenv("BOT_TOKEN")
if not TOKEN:
    raise ValueError("BOT_TOKEN –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")

WEBHOOK_URL = f"https://telegram-instabot-vhl4.onrender.com/{TOKEN}"
PORT = int(os.getenv("PORT", 10000))

# Flask-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
app = Flask(__name__)

# –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
telegram_app = None

class InstagramDownloader:
    def __init__(self):
        self.ydl_opts = {
            'format': 'best[ext=mp4]/best',
            'outtmpl': '%(title)s.%(ext)s',
            'quiet': True,
            'no_warnings': True,
        }
    
    def download_video(self, url):
        """–°–∫–∞—á–∏–≤–∞–µ—Ç –≤–∏–¥–µ–æ —Å Instagram –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É"""
        try:
            with tempfile.TemporaryDirectory() as temp_dir:
                self.ydl_opts['outtmpl'] = os.path.join(temp_dir, '%(title)s.%(ext)s')
                
                with yt_dlp.YoutubeDL(self.ydl_opts) as ydl:
                    # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∏–¥–µ–æ
                    info = ydl.extract_info(url, download=False)
                    title = info.get('title', 'instagram_video')
                    
                    # –°–∫–∞—á–∏–≤–∞–µ–º –≤–∏–¥–µ–æ
                    ydl.download([url])
                    
                    # –ù–∞—Ö–æ–¥–∏–º —Å–∫–∞—á–∞–Ω–Ω—ã–π —Ñ–∞–π–ª
                    for file in os.listdir(temp_dir):
                        if file.endswith(('.mp4', '.mkv', '.webm')):
                            file_path = os.path.join(temp_dir, file)
                            # –ß–∏—Ç–∞–µ–º —Ñ–∞–π–ª –≤ –ø–∞–º—è—Ç—å
                            with open(file_path, 'rb') as f:
                                return f.read(), title
            
            return None, None
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ –≤–∏–¥–µ–æ: {e}")
            return None, None

downloader = InstagramDownloader()

# –ö–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    welcome_text = (
        "üé¨ –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –≤–∏–¥–µ–æ —Å Instagram.\n\n"
        "üìã –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:\n"
        "‚Ä¢ –û—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ Instagram –ø–æ—Å—Ç/reel\n"
        "‚Ä¢ –ñ–¥–∏, –ø–æ–∫–∞ —è —Å–∫–∞—á–∞—é –≤–∏–¥–µ–æ\n"
        "‚Ä¢ –ü–æ–ª—É—á–∏ —Ñ–∞–π–ª!\n\n"
        "‚ö†Ô∏è –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—É–±–ª–∏—á–Ω—ã–µ –ø–æ—Å—Ç—ã"
    )
    await update.message.reply_text(welcome_text)

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message = update.message.text.strip()
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å—Å—ã–ª–∫–æ–π Instagram
    if not any(domain in message.lower() for domain in ["instagram.com", "instagr.am"]):
        await update.message.reply_text(
            "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É –Ω–∞ Instagram –ø–æ—Å—Ç –∏–ª–∏ reel."
        )
        return
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –Ω–∞—á–∞–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏
    processing_msg = await update.message.reply_text("‚è≥ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é —Å—Å—ã–ª–∫—É...")
    
    try:
        # –°–∫–∞—á–∏–≤–∞–µ–º –≤–∏–¥–µ–æ
        video_data, title = downloader.download_video(message)
        
        if video_data and title:
            # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ–±—Ä–∞–±–æ—Ç–∫–µ
            await processing_msg.delete()
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ (Telegram –ª–∏–º–∏—Ç 50MB)
            if len(video_data) > 50 * 1024 * 1024:
                await update.message.reply_text("‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (>50MB)")
                return
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤–∏–¥–µ–æ
            await update.message.reply_video(
                video=video_data,
                caption=f"üìπ {title[:100]}..." if len(title) > 100 else f"üìπ {title}",
                filename=f"{title[:50]}.mp4"
            )
            
            # –£–¥–∞–ª—è–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–æ —Å—Å—ã–ª–∫–æ–π
            try:
                await update.message.delete()
            except Exception as e:
                logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")
                
        else:
            await processing_msg.edit_text(
                "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ. –í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:\n"
                "‚Ä¢ –ü–æ—Å—Ç –ø—Ä–∏–≤–∞—Ç–Ω—ã–π\n"
                "‚Ä¢ –ù–µ–≤–µ—Ä–Ω–∞—è —Å—Å—ã–ª–∫–∞\n"
                "‚Ä¢ –í—Ä–µ–º–µ–Ω–Ω–∞—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å Instagram"
            )
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")
        await processing_msg.edit_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ –≤–∏–¥–µ–æ.")

# Flask –º–∞—Ä—à—Ä—É—Ç—ã
@app.route("/", methods=["GET"])
def health_check():
    return jsonify({
        "status": "alive",
        "timestamp": time.time(),
        "bot_status": "active" if telegram_app else "inactive"
    })

@app.route(f"/{TOKEN}", methods=["POST"])
def webhook():
    try:
        json_data = request.get_json(force=True)
        update = Update.de_json(json_data, telegram_app.bot)
        
        # –°–æ–∑–¥–∞–µ–º –∑–∞–¥–∞—á—É –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        asyncio.create_task(telegram_app.process_update(update))
        
        return "OK", 200
    except Exception as e:
        logger.error(f"Webhook error: {e}")
        return "ERROR", 500

# Keep-alive —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª
def keep_alive():
    """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –Ω–∞ Render"""
    while True:
        try:
            time.sleep(25 * 60)  # 25 –º–∏–Ω—É—Ç
            # –î–µ–ª–∞–µ–º –∑–∞–ø—Ä–æ—Å –∫ —Å–∞–º–æ–º—É —Å–µ–±–µ
            with httpx.Client(timeout=30) as client:
                response = client.get(f"https://telegram-instabot-vhl4.onrender.com/")
                logger.info(f"Keep-alive ping: {response.status_code}")
        except Exception as e:
            logger.error(f"Keep-alive error: {e}")

async def setup_telegram():
    """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ Telegram –±–æ—Ç–∞"""
    global telegram_app
    
    # –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    telegram_app = Application.builder().token(TOKEN).build()
    
    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Ö–µ–Ω–¥–ª–µ—Ä—ã
    telegram_app.add_handler(CommandHandler("start", start))
    telegram_app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    await telegram_app.initialize()
    
    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤–µ–±—Ö—É–∫
    async with httpx.AsyncClient(timeout=30) as client:
        webhook_url = f"https://api.telegram.org/bot{TOKEN}/setWebhook"
        response = await client.post(webhook_url, data={"url": WEBHOOK_URL})
        
        if response.status_code == 200:
            logger.info(f"‚úÖ –í–µ–±—Ö—É–∫ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {WEBHOOK_URL}")
        else:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤–µ–±—Ö—É–∫–∞: {response.text}")
            raise Exception("–ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤–µ–±—Ö—É–∫")
    
    logger.info("ü§ñ Telegram –±–æ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ")

def run_telegram_setup():
    """–ó–∞–ø—É—Å–∫ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ Telegram –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ"""
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.run_until_complete(setup_telegram())

if __name__ == "__main__":
    try:
        # –ó–∞–ø—É—Å–∫ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ Telegram –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
        telegram_thread = threading.Thread(target=run_telegram_setup, daemon=True)
        telegram_thread.start()
        
        # –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é
        time.sleep(5)
        
        # –ó–∞–ø—É—Å–∫ keep-alive –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
        keep_alive_thread = threading.Thread(target=keep_alive, daemon=True)
        keep_alive_thread.start()
        
        logger.info(f"üöÄ –ó–∞–ø—É—Å–∫ Flask —Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ –ø–æ—Ä—Ç—É {PORT}")
        
        # –ó–∞–ø—É—Å–∫ Flask —Å–µ—Ä–≤–µ—Ä–∞
        app.run(
            host="0.0.0.0", 
            port=PORT, 
            debug=False,
            threaded=True
        )
        
    except Exception as e:
        logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
        raise
